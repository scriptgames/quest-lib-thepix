<?xml version="1.0"?>
<library>
  <!--
  If you are viewing this on GitHub and want to download it, right click on the RAW button
  just above, and select "Save link as..."
  -->


  <!--
  NpcLib v2.2
  
  Documentation here:
  http://docs.textadventures.co.uk/quest/independent_npcs.html
  
  Quest version: 5.7
  Written by: The Pixie, 2017
  
  
  As of version 1.1:
  This uses functions from PathLib by Jay Nabonne to give the GoTo command
  http://docs.textadventures.co.uk/quest/libraries/path_library.html

  
  As of version 1.2
  If you use ConvLib, an NPC will be automatically paused, but this has to be after ConvLib!
  
  You can add an "npc_using" script to an exit to have that run instead of the standard
  phrase for moving. It has access to a local variable "npc". 
  It will need to check for itself if the player is present to see it happened
  (or use PrintIfHere).
  For standard moves, you can now override the templates below, or the NpcLeaving function
  (which   tells the player which way the NPC was heading).
  
  If game.npcdebug is set to true, you will see debugging info in blue; this will tell you
  what NPCs are dong and planning to do, which should help you work out why they are not behaving.
  
  There are also groups now; NPCs can join groups and act together whilst in the group.
  Discussion here
  http://textadventures.co.uk/forum/samples/topic/1gpwpfattuyocvlg1sievq/controlling-npcs
  
  As of version 1.3
  "Enter" and "leave" are conjugated so groups will "enter", an individual "enters"
  
  As of version 1.4 (with thanks to KV)
  Checks there is an "actions" attribute
  Various actions use CapFirst to capitalise the start of the sentence
  NPC entering message indicates the direction, and uses functions not templates
  New Follow option (and NpcFollow function). You can use the "followidle"
  attribute to have the NPC do something whilst the player is not moving
  
  As of version 1.5
  This is now useable with ClockLib 3.1 (but not 3.0 - check which you have)
  Note that you MUST use SetTime to set the initial time, as this will disable the
  standard NpcLib turnscript.
  You also need to use PrintIfHere in any NPC action or event that you want WAIT to stop for
  (or set game_clock.event = true).
  
  As of version 2.0
  The player can now give NPCs commands.
  https://github.com/ThePix/quest/wiki/Library:-NPCs
  Groups are properly set for gender, article and possessive (as long as "resetalias" is called).
  
  As of version 2.1 beta (with thanks to Doctor Agon)
  Some bugs resolved - thanks to Doctor Agon for the fixes (and finding them).
  Note that the messages printed when the player tries to sit or lie in a roomn where it is prohibited
  have been changed, and if you were using a previous version, they will have disappeared.
  They can be found on the Attributes tab, and copied across.
  
  Version 2.2 corrects a couple of bugs
  
  -->

  <!-- Languages -->
  <!-- English -->
  <!-- Used if the player asks an object that it not an NPC to do something -->
	<dynamictemplate name="PosturesNotGetOn">"That's not something you can get on."</dynamictemplate>
	<dynamictemplate name="PosturesAlreadyOn">"You're already on " + object.article + "."</dynamictemplate>
	<dynamictemplate name="PosturesAlreadyAre">"You already are."</dynamictemplate>
	<dynamictemplate name="PosturesNotOnObj">"You're not on " + object.article + "."</dynamictemplate>
	<dynamictemplate name="PosturesNotOnAny">"You're not on anything."</dynamictemplate>
	<dynamictemplate name="PosturesStandUp">"You stand up."</dynamictemplate>
	<dynamictemplate name="PosturesOnGround">"You ### on the ground."</dynamictemplate>
	<dynamictemplate name="PosturesOnSurface">"You ### on " + object.posture_surface + "."</dynamictemplate>
	<dynamictemplate name="PosturesCannotSitHere">"You cannot sit here."</dynamictemplate>
	<dynamictemplate name="PosturesCannotReclineHere">"You cannot lie down here."</dynamictemplate>
	<dynamictemplate name="PosturesNotNpc">"Tell " + object.article + " all you want, " + object.gender + "'s not going to do anything."</dynamictemplate>
	<dynamictemplate name="PosturesNpcNotOnObj">WriteVerb(object, "be") + " not on " + obj.article + "."</dynamictemplate>
	<dynamictemplate name="PosturesNpcNotOnAny">WriteVerb(object, "be") + " not on anything."</dynamictemplate>
	<dynamictemplate name="PosturesNpcStands">CapFirst(GetDisplayName(object)) + " stands up."</dynamictemplate>
	<dynamictemplate name="PosturesNpcAlreadyIs">CapFirst(object.gender) + " already is."</dynamictemplate>
	<dynamictemplate name="PosturesNpcCannotSitHere">"You (or anyone else!) can't sit here!"</dynamictemplate>
	<dynamictemplate name="PosturesNpcCannotReclineHere">"You (or anyone else!) can't lie down here!"</dynamictemplate>
  <template name="PosturesNotAllowedHere">You (or anyone else) can't ### here!</template>
  <template name="EditorNpcLibTypes">*=None; MaleNpc=Male NPC; FemaleNpc=Female NPC; NpcType=Generic NPC; GroupType=Group</template>
  <template name="EditorNpcLibAgreementMessage">Agreement message (will appear inside quotes; can use text processor)</template>
  <template name="EditorNpcLibCheckAgreementScript">Check agreement script</template>
  <template name="EditorNpcLibShouldSetCom">Should set "complies" attribute to true if the NPC is agreeable, false otherwise.</template>
  <template name="EditorNpcLibShouldGiveARes">Should give a response if the NPC refuses.</template>
  <template name="EditorNpcLibCanUseCom">Can use "command", "object" local variables.</template>
  <template name="EditorNpcLibScriptGivesObjAnoNpc">Script to run when this NPC is gives an object to another NPC</template>
  <template name="EditorNpcLibCanUseSubAndObjLocVar">Can use "subject" (the receiving NPC) and "object" local variables.</template>
  <template name="EditorNpcLibListOfActionsToPerform">List of actions to perform</template>
  <template name="EditorNpcLibActionPrompt">Action (eg Move:kitchen, or just text)</template>
  <template name="EditorNpcLibMove">Move: NPC will move directly to the indicated room</template>
  <template name="EditorNpcLibGoTo">GoTo: NPC will go to the specified location, one turn per room. Use GoToParent to have the NPC navigate to the same room as an item or another NPC.</template>
  <template name="EditorNpcLibGetDropGive">Get/Drop/Give: NPC will pick up/drop/give to the player the indicated item (whether it is there or not)</template>
  <template name="EditorNpcLibLockUnlockOpenCloseWearRemove">Lock/Unlock/Open/Close/Wear/Remove: NPC will lock/unlock/open/close/wear/remove the indicated item (whether it is there or not)</template>
  <template name="EditorNpcLibSitStandRecline">Sit/Stand/Recline: NPC will sit/stand/recline on the indicated item (whether it is there or not); use "Stand" with an item that is not furniture to have the NPC stand up.</template>
  <template name="EditorNpcLibSearch">Search: NPC will move via a random exit, and will continue to do so until in the same room as the indicated item</template>
  <template name="EditorNpcLibWait">Wait: NPC will wait, and will continue to do so until the player or other NPC is the same room if the indicated item is the player or an NPC, or the indicated item is unlocked if it has a "locked" attribute, or until given the indicated item otherwise.</template>
  <template name="EditorNpcLibPause">Pause: NPC does nothing for one turn.</template>
  <template name="EditorNpcLibScript">Script: Runs the NPC's "npcscript" script. If this sets the NPC's "deletefromlist" attribute to false, then this will run again next turn.</template>
  <template name="EditorNpcLibOwnVerbs">You can add your own verbs; add a new function called "Npc", followed by the verb, have it return a Boolean, and take two attributes, the NPC and the item.</template>
  <template name="EditorNpcLibTitleScript">Script</template>
  <template name="EditorNpcLibRunWithNpcScript">NPC script (run with NpcScript)</template>
  <template name="EditorNpcLibSetDelFromListToFalse">Set this.deletefromlist to false to have the script run again next turn.</template>
  <template name="EditorNpcLibTakeNpc">Take (NPC)</template>
  <template name="EditorNpcLibTakeNpcChk">Item can be taken by NPC</template>
  <template name="EditorNpcLibDropNpc">Drop (NPC)</template>
  <template name="EditorNpcLibDropNpcChk">Item can be dropped by NPC</template>
  <template name="EditorNpcLibStanding">Standing...</template>
  <template name="EditorNpcLibCanStandOn">Can stand on?</template>
  <template name="EditorNpcLibStandOnMsg">Stand on message</template>
  <template name="EditorNpcLibGetOffStandMsg">Get off message</template>
  <template name="EditorNpcLibNoStandingMsg">No standing message</template>
  <template name="EditorNpcLibSitting">Sitting...</template>
  <template name="EditorNpcLibCanSitOn">Can sit on?</template>
  <template name="EditorNpcLibSitOnMsg">Sit on message</template>
  <template name="EditorNpcLibGetOffSitMsg">Get off message</template>
  <template name="EditorNpcLibNoSittingMsg">No sitting message</template>
  <template name="EditorNpcLibReclining">Reclining...</template>
  <template name="EditorNpcLibCanReclineOn">Can recline on?</template>
  <template name="EditorNpcLibReclineOnMsg">Recline on message</template>
  <template name="EditorNpcLibGetOffRecMsg">Get off message</template>
  <template name="EditorNpcLibNoRecliningMessage">No reclining message</template>
  <template name="EditorNpcLibNote">Note: ### is used as a stand-in for this object (prepended by "the" if appropriate).</template>
  <template name="EditorNpcLibPostures">Postures</template>
  <template name="EditorNpcLibSurfaceName">Surface name</template>
  <template name="EditorNpcLibAvailableActions">Available actions:</template>
  <template name="EditorNpcLibItemsForNpcs">Items for NPCs</template>
  <template name="EditorNpcLibTakeDropTypes">null=Default behaviour;boolean=Boolean; script=Run script</template>
  <template name="EditorNpcLibNoSittingChk">Sitting/reclining prohibited</template>
  <template name="EditorNpcLibNameOfObjGiven">Name of object given</template>
  <template name="EditorNpcLibFurnitureType">*=None; furniture_type=Furniture</template>
  <template name="EditorNpcLibFurniture">Furniture</template>
  <template name="EditorNpcLibPreferredPosture">Preferred posture</template>
  <template name="EditorNpcLibNpcActions">NPC Actions</template>
  <template name="EditorNpcLibPerTurn">Perform actions after turn</template>
  <template name="EditorNpcLibPerTime">Perform actions after time</template>
  <template name="EditorNpcLibAfterTurn">Turns</template>
  <template name="EditorNpcLibYouStepUpOnTo">You step up on to ###.</template>
  <template name="EditorNpcLibYouStepOff">You step off ###.</template>
  <template name="EditorNpcLibYouCantStandOn">You can't stand on ###.</template>
  <template name="EditorNpcLibYouSitOn">You sit on ###.</template>
  <template name="EditorNpcLibYouGetOffSit">You get off ###.</template>
  <template name="EditorNpcLibYouCantSitOn">You can't sit on ###.</template>
  <template name="EditorNpcLibYouLieDownOn">You lie down on ###.</template>
  <template name="EditorNpcLibYouGetOffLie">You get off ###.</template>
  <template name="EditorNpcLibYouCantRecOn">You can't recline on ###.</template>

  <!-- Zur Umstellung auf Deutsch folgende Zeilen einklammern -->
  <!-- Deutsch -->
  <!-- -->
	<dynamictemplate name="PosturesNotGetOn">"Das ist nichts, worauf man sich setzen kann."</dynamictemplate>
	<dynamictemplate name="PosturesAlreadyOn">"Du bist schon auf " + object.article + "."</dynamictemplate>
	<dynamictemplate name="PosturesAlreadyAre">"Das bist du schon."</dynamictemplate>
	<dynamictemplate name="PosturesNotOnObj">"Du bist nicht auf " + object.article + "."</dynamictemplate>
	<dynamictemplate name="PosturesNotOnAny">"Du bist auf nichts."</dynamictemplate>
	<dynamictemplate name="PosturesStandUp">"Du stehst auf."</dynamictemplate>
	<dynamictemplate name="PosturesOnGround">"Du ### auf dem Boden."</dynamictemplate>
	<dynamictemplate name="PosturesOnSurface">"DU ### auf " + object.posture_surface + "."</dynamictemplate>
	<dynamictemplate name="PosturesCannotSitHere">"Du kannst hier nicht sitzen."</dynamictemplate>
	<dynamictemplate name="PosturesCannotReclineHere">"Du kannst hier nicht liegen."</dynamictemplate>
	<dynamictemplate name="PosturesNotNpc">"Sag " + object.article + " alles was du willst. " + object.gender + " wird es nicht tun."</dynamictemplate>
	<dynamictemplate name="PosturesNpcNotOnObj">WriteVerb(object, "be") + " nicht auf " + obj.article + "."</dynamictemplate>
	<dynamictemplate name="PosturesNpcNotOnAny">WriteVerb(object, "be") + " nicht auf alles."</dynamictemplate>
	<dynamictemplate name="PosturesNpcStands">CapFirst(GetDisplayName(object)) + " steht auf."</dynamictemplate>
	<dynamictemplate name="PosturesNpcAlreadyIs">CapFirst(object.gender) + " ist bereits vorhanden."</dynamictemplate>
	<dynamictemplate name="PosturesNpcCannotSitHere">"Niemand kann hier sitzen!"</dynamictemplate>
	<dynamictemplate name="PosturesNpcCannotReclineHere">"Niemand kann hier liegen!"</dynamictemplate>
  <template name="PosturesNotAllowedHere">Niemand kann hier ###!</template>
  <template name="EditorNpcLibTypes">*=Ohne; MaleNpc=Männlicher NPC; FemaleNpc=Weiblicher NPC; NpcType=Generischer NPC; GroupType=Gruppe</template>
  <template name="EditorNpcLibAgreementMessage">Arrangement-Nachricht (wird in Anführungszeichen ausgegeben; Unterstützt ProcessText!)</template>
  <template name="EditorNpcLibCheckAgreementScript">Arrangement-Skript</template>
  <template name="EditorNpcLibShouldSetCom">Wenn der NPC mit dem Arrangement einverstanden sein soll, das Attribut "complies" auf true setzen. Ansonsten auf false.</template>
  <template name="EditorNpcLibShouldGiveARes">Es sollte eine Antwort ausgegeben werden, wenn der NPC nicht mit dem Arrangement einverstanden ist.</template>
  <template name="EditorNpcLibCanUseCom">Es können "command", "object" und lokale Variablen verwendet werden.</template>
  <template name="EditorNpcLibScriptGivesObjAnoNpc">Skript wird ausgeführt, wenn dieser NPC ein Objekt an einen anderen NPC weitergibt</template>
  <template name="EditorNpcLibCanUseSubAndObjLocVar">Es können "subject" (der empfangende NPC), "object" und lokale Variablen verwendet werden.</template>
  <template name="EditorNpcLibListOfActionsToPerform">Liste der auszuführenden Aktionen</template>
  <template name="EditorNpcLibActionPrompt">Aktion (z.B. Move:kitchen, oder Ausgabetext)</template>
  <template name="EditorNpcLibMove">Move: Der NPC wechselt direkt in den angegebenen Raum</template>
  <template name="EditorNpcLibGoTo">GoTo: Der NPC geht in den angegebenen Raum, Ein Spielzug pro Raum. Verwende GoToParent, um den NPC in den gleichen Raum wie das angegebene Objekt oder einen anderen NPC navigieren zu lassen.</template>
  <template name="EditorNpcLibGetDropGive">Get/Drop/Give: Der NPC wird das angegebene Objekt vom Spieler nehmen / Er wird es fallen lassen / Er wird es dem Spieler geben (Es kann dabei vorhanden sein oder nicht).</template>
  <template name="EditorNpcLibLockUnlockOpenCloseWearRemove">Lock/Unlock/Open/Close/Wear/Remove: Der NPC wird das angegebene Objekt sperren/entsperren/öffnen/schließen/anziehen/ausziehen (Er kann dabei vorhanden sein oder nicht).</template>
  <template name="EditorNpcLibSitStandRecline">Sit/Stand/Recline: Der NPC wird auf dem angegebenen Objekt sitzen/stehen/liegen (Er kann dabei vorhanden sein oder nicht). Verwenden Sie "Stand" mit einem Objekt, das kein Möbelstück ist, um den NPC hinzustellen.</template>
  <template name="EditorNpcLibSearch">Search: Der NPC bewegt sich solange über einen zufällig gewählten Ausgang, bis er sich im selben Raum wie das angegebene Objekt befindet.</template>
  <template name="EditorNpcLibWait">Wait: Der NPC wartet solange, bis der Spieler oder ein anderer NPC den gleichen Raum betreten hat.</template>
  <template name="EditorNpcLibPause">Pause: Der NPC pausiert für einen Spielzug.</template>
  <template name="EditorNpcLibScript">Script: Führt das "npcscript"-Skript des NPC aus. Setze das Attribut "deletefromlist" des NPC auf false, damit es in der nächsten Spielzug wieder ausgeführt wird.</template>
  <template name="EditorNpcLibOwnVerbs">Du kannst deine eigenen Verben hinzufügen. Dazu einfach eine neue Funktion namens "Npc", gefolgt vom Verb, erstellen (z. B. NpcTake). Die Funktion muss ein booleaschen Wert für die erfolgreiche Ausführung zurückgeben. Zudem müssen zwei Attribute für den NPC und das Objekt übergeben werden.</template>
  <template name="EditorNpcLibTitleScript">Skript</template>
  <template name="EditorNpcLibRunWithNpcScript">NPC-Skript (Ausführbar per NpcScript)</template>
  <template name="EditorNpcLibSetDelFromListToFalse">Setze das Attribut "this.deletefromlist" auf false, damit das Skript beim nächsten Spielzug wieder ausgeführt wird.</template>
  <template name="EditorNpcLibTakeNpc">Nimm (NPC)</template>
  <template name="EditorNpcLibTakeNpcChk">Muster kann von NPC übernommen werden</template>
  <template name="EditorNpcLibDropNpc">Lege (NPC)</template>
  <template name="EditorNpcLibDropNpcChk">Template kann vom NPC gelöscht werden</template>
  <template name="EditorNpcLibStanding">Stehen...</template>
  <template name="EditorNpcLibCanStandOn">Es ist Möglich, sich auf das Objekt zu stellen</template>
  <template name="EditorNpcLibStandOnMsg">Nachricht, die beim draufstellen angezeigt wird</template>
  <template name="EditorNpcLibGetOffStandMsg">Nachricht, die beim verlassen des Objekts angezeigt wird</template>
  <template name="EditorNpcLibNoStandingMsg">Nachricht, wenn ein draufstellen nicht möglich ist</template>
  <template name="EditorNpcLibSitting">Sitzen...</template>
  <template name="EditorNpcLibCanSitOn">Es ist Möglich, sich auf das Objekt zu setzen</template>
  <template name="EditorNpcLibSitOnMsg">Nachricht, die beim hinsetzen angezeigt wird</template>
  <template name="EditorNpcLibGetOffSitMsg">Nachricht, die beim aufstehen angezeigt wird</template>
  <template name="EditorNpcLibNoSittingMsg">Nachricht, die angezeigt wird, wenn ein hinsetzen nicht möglich ist</template>
  <template name="EditorNpcLibReclining">Liegen...</template>
  <template name="EditorNpcLibCanReclineOn">Es ist Möglich, sich auf das Objekt zu legen</template>
  <template name="EditorNpcLibReclineOnMsg">Nachricht, die beim hinlegen angezeigt wird</template>
  <template name="EditorNpcLibGetOffRecMsg">Nachricht, die beim aufstehen angezeigt wird</template>
  <template name="EditorNpcLibNoRecliningMessage">Nachricht, die angezeigt wird, wenn ein hinlegen nicht möglich ist</template>
  <template name="EditorNpcLibNote">Hinweis: ### wird als Platzhalter für dieses Objekt verwendet (ggf. mit "der, die, das" vorangestellt).</template>
  <template name="EditorNpcLibPostures">Positionen</template>
  <template name="EditorNpcLibSurfaceName">Oberflächenname</template>
  <template name="EditorNpcLibAvailableActions">Verfügbare Aktionen:</template>
  <template name="EditorNpcLibItemsForNpcs">Objekte für NPCs</template>
  <template name="EditorNpcLibTakeDropTypes">null=Standard;boolean=Boolesch; script=Skript starten</template>
  <template name="EditorNpcLibNoSittingChk">Kein sitzen oder liegen</template>
  <template name="EditorNpcLibNameOfObjGiven">Name des zu gebenden Objekts</template>
  <template name="EditorNpcLibFurnitureType">*=Kein Möbelstück; furniture_type=Möbelstück</template>
  <template name="EditorNpcLibFurniture">Möbelstück</template>
  <template name="EditorNpcLibPreferredPosture">Bevorzugte Positionsart</template>
  <template name="EditorNpcLibNpcActions">Aktionen der NPCs</template>
  <template name="EditorNpcLibPerTurn">Aktionen nach Turn ausführen</template>
  <template name="EditorNpcLibPerTime">Aktionen nach Zeit ausführen</template>
  <template name="EditorNpcLibAfterTurn">Turns</template>
  <template name="EditorNpcLibAfterTime">Sekunden</template>
  <template name="EditorNpcLibYouStepUpOnTo">Du steigst auf ###.</template>
  <template name="EditorNpcLibYouStepOff">Du steigst von ### herunter.</template>
  <template name="EditorNpcLibYouCantStandOn">Du kannst nicht auf ### stehen.</template>
  <template name="EditorNpcLibYouSitOn">Du setzt dich auf ###.</template>
  <template name="EditorNpcLibYouGetOffSit">Du stehst von ### auf.</template>
  <template name="EditorNpcLibYouCantSitOn">Du kannst nicht auf ### sitzen.</template>
  <template name="EditorNpcLibYouLieDownOn">Du legst dich auf ###.</template>
  <template name="EditorNpcLibYouGetOffLie">Du stehst von ### auf.</template>
  <template name="EditorNpcLibYouCantRecOn">Du kannst dich nicht auf ### legen.</template>

  <!-- -->


  <verb name="standon">
    <property>stand</property>
    <pattern>stand on #object#;stand #object#;stand upon #object#</pattern>
    <defaultexpression>"You can't stand on " + object.article + "."</defaultexpression>
  </verb>
  
  <verb name="reclineon">
    <pattern>lie on #object#; lie upon #object#; lie down on #object#; lie down upon #object#;recline on #object#;recline upon #object#</pattern>
    <property>recline</property>
    <defaultexpression>"You can't recline on " + object.article + "."</defaultexpression>
  </verb>

  
  

  
  <command name="cmd_sit">
    <pattern>sit;sit down</pattern>
    <scope>none</scope>
    <script>
      PostureCommand("sit")
    </script>
  </command>

  <command name="cmd_recline">
    <pattern>lie;lie down;recline</pattern>
    <scope>none</scope>
    <script>
      PostureCommand("recline")
    </script>
  </command>  
  
  <command name="cmd_kneel">
    <pattern>kneel;kneel down;kneel up</pattern>
    <scope>none</scope>
    <script>
      if (HasString(game.pov.parent, "posture_surface")) {
        PostureGroundCommand ("kneel", "PosturesOnSurface")
      }
      else {
        PostureGroundCommand ("kneel", "PosturesOnGround")
      }
    </script>
  </command>  
  
  <command name="cmd_crouch">
    <pattern>crouch;crouch down;squat;squat down</pattern>
    <scope>none</scope>
    <script>
      if (HasString(game.pov.parent, "posture_surface")) {
        PostureGroundCommand ("crouch", "PosturesOnSurface")
      }
      else {
        PostureGroundCommand ("crouch", "PosturesOnGround")
      }
    </script>
  </command>  
  
  <command name="cmd_crawl">
    <pattern>crawl;get on hands and knees;get on my hands and knees;get on all fours</pattern>
    <scope>none</scope>
    <script>
      if (HasString(game.pov.parent, "posture_surface")) {
        PostureGroundCommand ("crawl", "PosturesOnSurface")
      }
      else {
        PostureGroundCommand ("crawl", "PosturesOnGround")
      }
    </script>
  </command>  
  
  <command name="cmd_get_on_object">
    <pattern>get on #object#;on #object#</pattern>
    <script>
      if (not DoesInherit(object, "furniture_type")) {
        msg(DynamicTemplate("PosturesNotGetOn", object))
      }
      else if (game.pov.posture = object) {
        msg(DynamicTemplate("PosturesAlreadyOn", object))
      }
      else {
        do (object, object.preferred_posture)
      }
    </script>
  </command>
  
  <command name="cmd_stand">
    <pattern>stand;stand up</pattern>
    <script>
      if (game.pov.posture = null) {
        msg(DynamicTemplate("PosturesAlreadyAre", game))
      }
      else {
        StandUp
      }
    </script>
  </command>
  
  <command name="cmd_get_off_obj">
    <pattern>get off #object#;off #object#</pattern>
    <script>
      if (not game.pov.posture = object) {
        msg(DynamicTemplate("PosturesNotOnObj", object))
      }
      else {
        StandUp
      }
    </script>
  </command>
  
  <command name="cmd_get_off">
    <pattern>get off;off</pattern>
    <script>
      if (game.pov.posture = null) {
        msg(DynamicTemplate("PosturesNotOnAny", game))
      }
      else {
        StandUp
      }
    </script>
  </command>
  
  <command name="cmd_sit_on_ground">
    <pattern type="string"><![CDATA[^(sit down|sit) on (the |)(ground|floor)$]]></pattern>
    <scope>none</scope>
    <script>
      if (HasString(game.pov.parent, "posture_surface")) {
        PostureGroundCommand ("sit", "PosturesOnSurface")
      }
      else {
        PostureGroundCommand ("sit", "PosturesOnGround")
      }
    </script>
  </command>

  <command name="cmd_recline_on_ground">
    <pattern type="string"><![CDATA[^(lie down|lie|recline) on (the |)(ground|floor)$]]></pattern>
    <scope>none</scope>
    <script>
      if (HasString(game.pov.parent, "posture_surface")) {
        PostureGroundCommand ("recline", "PosturesOnSurface")
      }
      else {
        PostureGroundCommand ("recline", "PosturesOnGround")
      }
    </script>
  </command>

  
  
  

  <function name="PostureCommand" parameters="posture">
    <![CDATA[
      obj = FindFurniture(posture, game.pov.parent)
      if (not obj = null) {
        Posture (posture, GetString(obj, posture + "onmsg"), obj)
      }
      else if (GetBoolean(game.pov.parent, "nositting")) {
        if (HasString(game.pov.parent, "no" + posture + "msg")) {
          msg(GetString(game.pov.parent, "no" + posture + "msg"))
        }
        else {
          msg (Replace(Template("PosturesNotAllowedHere"), "###", posture))
        }
      }
      else if (HasString(game.pov.parent, "posture_surface")) {
        PostureGroundCommand (posture, "PosturesOnSurface")
      }
      else {
        PostureGroundCommand (posture, "PosturesOnGround")
      }
    ]]>
  </function>
  
  <!--
  Allows author to add additional checks before allowing the player to move
  -->
  <function name="ExitCheck" parameters="exit" type="boolean">
    return (true)
  </function>
  
  <function name="PostureGroundCommand" parameters="posture, template" type="object">
    if (game.pov.parent.nositting) {
      msg(Replace(Template("PosturesNotAllowedHere"), "###", option))
    }
    else {
      Posture (posture, Replace(DynamicTemplate(template, game.pov.parent), "###", posture), null)
    }
  </function>
  
  
  <function name="FindFurniture" parameters="posture, location" type="object">
    <![CDATA[
      furniture_list = FilterByType(GetDirectChildren(location), "furniture_type")
      furniture_list = FilterByAttribute (furniture_list, "can" + posture + "on", true)
      if (ListCount(furniture_list) > 0) {
        // there is some furniture here.
        // If any have this as the prefered posture, just go with the first one
        l = FilterByAttribute (furniture_list, "preferred_posture", posture)
        if (ListCount(l) > 0) {
          return (ObjectListItem(l, 0))
        }
        return (ObjectListItem(furniture_list, 0))
      }
      else {
        return (null)
      }
    ]]>
  </function>
  
  
  <function name="StandUp">
    if (not game.pov.posture = null) {
      if (game.pov.posture_object = null) {
        game.pov.posture = null
        msg (DynamicTemplate("PosturesStandUp", game))
      }
      else {
        att = game.pov.posture + "offmsg"
        if (HasString(game.pov.posture_object, att)) {
          msg(Replace(GetString(game.pov.posture_object, att), "###", GetDefiniteName(game.pov.posture_object)))
        }
        else {
          msg (DynamicTemplate("PosturesStandUp", game))
        }
        game.pov.posture_object = null
        game.pov.posture = null
      }
      JS.updateLocation (CapFirst(GetDisplayName(game.pov.parent)))
      PostureRemoveExit()
    }
  </function>
  
  
  <function name="Posture" parameters="posture, message, obj">
    // This just does the action; there is no checking it is allowed or anything except alreadsy done
    if (game.pov.posture = posture and game.pov.posture_object = obj) {
      msg(DynamicTemplate("PosturesAlreadyAre", game))
    }
    else {
      if (not game.pov.posture_object = obj) {
        StandUp()
      }
      game.pov.posture = posture
      game.pov.posture_object = obj
      if (obj = null) {
        // !!!lang
        JS.updateLocation (CapFirst(GetDisplayName(game.pov.parent)) + " (" + posture + ")")
        msg (message)
      }
      else {
        // !!!lang
        JS.updateLocation (CapFirst(GetDisplayName(game.pov.parent)) + " (" + posture + " on " + ProcessText(GetDisplayName(obj)) + ")")
        msg (Replace(message, "###", GetDefiniteName(obj)))
      }
      if (posture = "stand") {
        PostureAddExit("down")
      }
      else {
        PostureAddExit("up")
      }
    }
  </function>
  
  
  <function name="PostureAddExit" parameters="dir">
    PostureRemoveExit()
    o = GetObject("posture_exit_" + dir)
    if (o = null) {
      create exit ("posture_exit_" + dir, dir, game.pov.parent, game.pov.parent, dir + "direction")
      o = GetObject("posture_exit_" + dir)
      o.scenery = true
      o.runscript = true
      o.script => {
        StandUp
      }
    }
    else {
      o.parent = game.pov.parent
      o.to = game.pov.parent
    }
    s = GetExitByName (game.pov.parent, dir)
    if (not s = null) {
      o.old_exit = GetObject(s)
      if (o.old_exit.visible) {
        o.old_exit.visible = false
      }
      else {
        o.old_exit = null
      }
    }
  </function>
  
  
  <function name="PostureRemoveExit">
    o = GetObject("posture_exit_up")
    if (not o = null) {
      o.parent = null
      if (not o.old_exit = null) {
        o.old_exit.visible = true
      }
    }
    o = GetObject("posture_exit_down")
    if (not o = null) {
      o.parent = null
      if (not o.old_exit = null) {
        o.old_exit.visible = true
      }
    }
  </function>

  
  

  <!--
  Support for NPCs
  -->  
  
  
  


  
  
  
  
  <command name="cmd_tell_to_recline">
    <pattern type="string"><![CDATA[^((tell|ask) (?<objectnpc>.*) to|(?<objectnpc>.*),) (recline|lie down|lie)$]]></pattern>
    <script>
      NpcAskToPosture(objectnpc, null, "recline")
    </script>
  </command>

  <command name="cmd_tell_to_sit">
    <pattern type="string"><![CDATA[^((tell|ask) (?<objectnpc>.*) to|(?<objectnpc>.*),) (sit down|sit)$]]></pattern>
    <script>
      NpcAskToPosture(objectnpc, null, "sit")
    </script>
  </command>

  <command name="cmd_tell_to_kneel">
    <pattern type="string"><![CDATA[^((tell|ask) (?<objectnpc>.*) to|(?<objectnpc>.*),) (kneel down|kneel up|kneel)$]]></pattern>
    <script>
      NpcAskToPosture(objectnpc, null, "kneel")
    </script>
  </command>

  <command name="cmd_tell_to_crouch">
    <pattern type="string"><![CDATA[^((tell|ask) (?<objectnpc>.*) to|(?<objectnpc>.*),) (crouch down|crouch|squat down|squat)$]]></pattern>
    <script>
      NpcAskToPosture(objectnpc, null, "crouch")
    </script>
  </command>

  <command name="cmd_tell_to_crawl">
    <pattern type="string"><![CDATA[^((tell|ask) (?<objectnpc>.*) to|(?<objectnpc>.*),) (grovel|crawl|(get down on|get on|get down on his|get down on its|get down on her|get on his|get on its|get on her) (hands and knees|all fours))$]]></pattern>
    <script>
      NpcAskToPosture(objectnpc, null, "crawl")
    </script>
  </command>

  <command name="cmd_tell_to_get_on_object">
    <pattern type="string"><![CDATA[^((tell|ask) (?<objectnpc>.*) to|(?<objectnpc>.*),) (get on|on) (?<object>.*)$]]></pattern>
    <script>
      if (not DoesInherit(object, "furniture_type")) {
        // Not furniture
        msg(DynamicTemplate("PosturesNotGetOn", objectnpc))
      }
      else {
        NpcAskToPosture(objectnpc, object, object.preferred_posture)
      }
    </script>
  </command>
  

  
  <command name="cmd_tell_to_stand_on_object">
    <pattern type="string"><![CDATA[^((tell|ask) (?<objectnpc>.*) to|(?<objectnpc>.*),) (stand on|stand|step on to|step on) (?<object>.*)$]]></pattern>
    <script>
      NpcAskToPosture(objectnpc, object, "stand")
    </script>
  </command>
  
  <command name="cmd_tell_to_sit_on_object">
    <pattern type="string"><![CDATA[^((tell|ask) (?<objectnpc>.*) to|(?<objectnpc>.*),) (sit down on|sit on|sit) (?<object>.*)$]]></pattern>
    <script>
      NpcAskToPosture(objectnpc, object, "sit")
    </script>
  </command>

  <command name="cmd_tell_to_recline_on_object">
    <pattern type="string"><![CDATA[^((tell|ask) (?<objectnpc>.*) to|(?<objectnpc>.*),) (recline on|recline|lie down on|lie on|lie) (?<object>.*)$]]></pattern>
    <script>
      NpcAskToPosture(objectnpc, object, "recline")
    </script>
  </command>
  
  <command name="cmd_tell_to_stand">
    <pattern type="string"><![CDATA[^((tell|ask) (?<objectnpc>.*) to|(?<objectnpc>.*),) (stand up|stand)$]]></pattern>
    <script>
      NpcAskToStandUp(objectnpc, null)
    </script>
  </command>
  
  <command name="cmd_tell_to_get_off_obj">
    <pattern type="string"><![CDATA[^((tell|ask) (?<objectnpc>.*) to|(?<objectnpc>.*),) (get off|off) (?<object>.*)$]]></pattern>
    <script>
      NpcAskToStandUp(objectnpc, object)
    </script>
  </command>
  
  <command name="cmd_tell_to_get_off">
    <pattern type="string"><![CDATA[^((tell|ask) (?<objectnpc>.*) to|(?<objectnpc>.*),) (get off|off|get down)$]]></pattern>
    <script>
      NpcAskToStandUp(objectnpc, null)
    </script>
  </command>  
  

  




  
  
  <function name="NpcAskToStandUp" parameters="npc, obj">
    if (not DoesInherit(npc, "NpcType")) {
      msg(DynamicTemplate("PosturesNotNpc", npc))
    }
    else if (not obj = null and not npc.posture_object = obj) {
      msg (DynamicTemplate("PosturesNpcNotOnObj", obj))
    }
    else {
      do (npc, "requeststandup", QuickParams("object", obj))
    }
  </function>
  


 
  <function name="NpcAskToPosture" parameters="npc, obj, posture">
    if (not DoesInherit(npc, "NpcType")) {
      msg(DynamicTemplate("PosturesNotNpc", npc))
    }
    else if (not obj = null and not DoesInherit(obj, "furniture_type")) {
      // Not furniture
      msg (DynamicTemplate("PosturesNotGetOn", obj))
    }
    else {
      do (npc, "requestposture", QuickParams("object", obj, "option", posture))
    }
  </function>
  
  
  
  <command name="go">
    <pattern type="string"><![CDATA[^go to (?<exit>.*)$|^go (?<exit>.*)$|^(?<exit>north|east|south|west|northeast|northwest|southeast|southwest|in|out|up|down|n|e|s|w|ne|nw|se|sw|o|u|d)$]]></pattern>
    <unresolved>[UnresolvedLocation]</unresolved>
    <script>
      old = game.pov.parent
      if (exit.visible) {
        if (not ExitCheck(exit)) {
          // nothing
        }
        else if (exit.locked) {
          msg (exit.lockmessage)
        }
        else if (exit.runscript) {
          StandUp
          if (HasScript(exit, "script")) {
            do (exit, "script")
          }
        }
        else if (exit.lookonly) {
          msg ([UnresolvedLocation])
        }
        else {
          StandUp
          if (HasString(exit, "message")) {
            if (not exit.message = "") {
              if (game.clearscreenonroomenter) {
                game.currentexitmessage = exit.message
              }
              else {
                msg (exit.message)
              }
            }
          }
          game.pov.parent = exit.to
        }
      }
      else {
        msg ([UnresolvedLocation])
      }
      if (not old = game.pov.parent) {
        foreach (npc, FilterByAttribute(AllObjects(), "following", game.pov)) {
          NpcFollow (npc, game.pov)
        }
      }
    </script>
  </command>

  



  <!--
  Support for NPCs
  -->  
  
  <command name="cmd_tell_to_go_place">
    <pattern type="string"><![CDATA[^((tell|ask) (?<objectnpc>.*) to|(?<objectnpc>.*),) go to (?<object>.*)$]]></pattern>
    <unresolved>That's not somewhere you can get to.</unresolved>
    <scope>objectnpc=all|object=world</scope>
    <script>
      if (not DoesInherit(objectnpc, "NpcType")) {
        msg (DynamicTemplate("PosturesNotNpc", objectnpc))
      }
      else if (objectnpc.parent = object) {
        msg ("'I'm already here!'")
      }
      else if (GetRoute(objectnpc, object) = null) {
        msg ("'That's not somewhere I can get to.'")
      }
      else {
        do (objectnpc, "checkagreement", QuickParams("command", "goto", "object", object))
        if (objectnpc.complies) {
          objectnpc.savedactions = objectnpc.actions
          msg ("'" + objectnpc.yesmsg + "' says " + CapFirst(GetDefiniteName(objectnpc)) + ".")
          objectnpc.actions = Split("GoTo:" + object.name)
        }
      }
    </script>
  </command>  
  
  <command name="cmd_tell_to_go_exit">
    <pattern type="string"><![CDATA[^((tell|ask) (?<objectnpc>.*) to|(?<objectnpc>.*),) (go |)(?<exit>north|east|south|west|northeast|northwest|southeast|southwest|in|out|up|down|n|e|s|w|ne|nw|se|sw|o|u|d)$]]></pattern>
    <unresolved>That's not somewhere you can go.</unresolved>
    <script>
      // WARNING: This does not allow for doors that are stopped by scripts
      if (not DoesInherit(objectnpc, "NpcType")) {
        msg(DynamicTemplate("PosturesNotNpc", objectnpc))
      }
      else if (not exit.visible) {
        msg ([UnresolvedLocation])
      }
      else {
        do (objectnpc, "requestgo", QuickParams("object", exit))
      }
    </script>
  </command>
  
  
  
  
  <command name="cmd_tell_to_follow">
    <pattern type="string"><![CDATA[^((tell|ask) (?<objectnpc>.*) to|(?<objectnpc>.*),) (follow me|follow)$]]></pattern>
    <script>
      if (not DoesInherit(objectnpc, "NpcType")) {
        msg(DynamicTemplate("PosturesNotNpc", objectnpc))
      }
      else {
        do (objectnpc, "requestfollow")
      }        
    </script>
  </command>

  <command name="cmd_tell_to_wait">
    <pattern type="string"><![CDATA[^((tell|ask) (?<objectnpc>.*) to|(?<objectnpc>.*),) (stop following|don't follow|do not follow|wait here|wait)( me|)$]]></pattern>
    <script>
      if (not DoesInherit(objectnpc, "NpcType")) {
        msg(DynamicTemplate("PosturesNotNpc", objectnpc))
      }
      else {
        do (objectnpc, "requestwait")
      }        
    </script>
  </command>
  


  
  <command name="cmd_tell_to_get_object">
    <pattern type="string"><![CDATA[^((tell|ask) (?<objectnpc>.*) to|(?<objectnpc>.*),) (get|take|pick up) (?<object>.*)$]]></pattern>
    <script>
      if (not DoesInherit(objectnpc, "NpcType")) {
        msg(DynamicTemplate("PosturesNotNpc", objectnpc))
      }
      else if (object = objectnpc) {
        msg("You want " + objectnpc.article + " to pick " + object.article + "self up?")
      }
      else if (DoesInherit(object, "npc_type")) {
        msg(CapFirst(objectnpc.gender) + " is not going to pick " + object.article + " up.")
      }
      //else if (not ListContains(ScopeVisibleNotHeldForRoom(objectnpc.parent), object)) {
      //  msg(WriteVerb(object, "is") + " not where someone can get " + object.article + ".")
      //}
      else {
        do(objectnpc, "requestget", QuickParams("object", object))
      }
    </script>
  </command>

  <command name="cmd_tell_to_drop_object">
    <pattern type="string"><![CDATA[^((tell|ask) (?<objectnpc>.*) to|(?<objectnpc>.*),) (drop) (?<object>.*)$]]></pattern>
    <scope>none</scope>
    <changecommandscope type="script">
      foreach (npc, FilterByType(ScopeVisibleNotHeldForRoom (game.pov.parent), "NpcType")) {
        foreach (obj, GetDirectChildren(npc)) {
          list add (items, obj)
        }
      }
    </changecommandscope>
    <script>
      if (not DoesInherit(objectnpc, "NpcType")) {
        msg(DynamicTemplate("PosturesNotNpc", objectnpc))
      }
      else if (not object.parent = objectnpc) {
        msg(WriteVerb(objectnpc, "do") + " not have " + object.article + ".")
      }
      else {
        do(objectnpc, "requestdrop", QuickParams("object", object))
      }
    </script>
  </command>

  <command name="cmd_tell_to_give_object">
    <pattern type="string"><![CDATA[^((tell|ask) (?<objectnpc>.*) to|(?<objectnpc>.*),) (give me|give) (?<object>.*)$]]></pattern>
    <scope>none</scope>
    <changecommandscope type="script">
      foreach (npc, FilterByType(ScopeVisibleNotHeldForRoom (game.pov.parent), "NpcType")) {
        foreach (obj, GetDirectChildren(npc)) {
          list add (items, obj)
        }
      }
    </changecommandscope>
    <script>
      NpcAskToGiveTo(objectnpc, object, game.pov)
    </script>
  </command>
  <command name="cmd_tell_to_give_object2">
    <pattern type="string"><![CDATA[^((tell|ask) (?<objectnpc>.*) to|(?<objectnpc>.*),) (give) (?<object>.*) to (?<object2>.*)$]]></pattern>
    <scope>none</scope>
    <changecommandscope type="script">
      foreach (npc, FilterByType(ScopeVisibleNotHeldForRoom (game.pov.parent), "NpcType")) {
        foreach (obj, GetDirectChildren(npc)) {
          list add (items, obj)
        }
      }
    </changecommandscope>
    <script>
      NpcAskToGiveTo(objectnpc, object, object2)
    </script>
  </command>


  
  <function name="NpcAskToGiveTo" parameters="npc, object, subject">
    if (not DoesInherit(npc, "NpcType")) {
      msg(DynamicTemplate("PosturesNotNpc", npc))
    }
    else if (not object.parent = npc) {
      msg(WriteVerb(npc, "do") + " not have " + object.article + ".")
    }
    else {
      msg ("Giving " + object.name + " to " + subject.name)
      do(npc, "requestgive", QuickParams("object", object, "subject", subject))
    }
  </function>



  
  
  



  
  <type name="NpcType">
    <takeaturn type="script"><![CDATA[
      // Checks to see if "actions" has been set up (meaning at least on action has been added) to avoid errors.
      if(HasAttribute(this, "actions")){
        if (ListCount(this.actions) > 0){
          PrintIfDebug (this, "Outstanding actions: " + Join(this.actions, ","))
        }
        if (ListCount(this.actions) > 0 and not HasAttribute(this, "group")) {
          s = StringListItem(this.actions, 0)
          PrintIfDebug (this, "Doing: " + s)
          if (NpcAct (this, s)) {
            list remove (this.actions, s)
            PrintIfDebug (this, "Deleted")
          }
        }
      }
    ]]></takeaturn>
    

    <!-- General -->

    <checkagreement type="script">
      this.complies = true
    </checkagreement>
    <yesmsg>Okay!</yesmsg>

    <perturn type="boolean">true</perturn>
    <pertime type="boolean">false</pertime>
    <afterturn type="int">1</afterturn>
    <aftertime type="int">5</aftertime>
    <pastturn type="int">1</pastturn>
    <pasttime type="int">1</pasttime>

    <requestget type="script">
      do (this, "checkagreement", QuickParams("command", "take", "object", object))
      if (this.complies) {
        if (HasScript(object, "npc_take")) {
          do (object, "npc_take", QuickParams("npc", this))
        }
        else if ((HasBoolean(object, "npc_take") and not GetBoolean(object, "npc_take")) or (not HasAttribute(object, "npc_take") and not GetBoolean(object, "take"))) {
          msg ("'I can't get that,' says " + GetDefiniteName(this) + ".")
        }
        else {
          if (object.parent = game.pov) {
            msg ("'" + this.yesmsg + "' says " + CapFirst(GetDefiniteName(this)) + ", taking " + GetDefiniteName(object) + " from you.")
          }
          else {
            msg ("'" + this.yesmsg + "' says " + CapFirst(GetDefiniteName(this)) + ", picking " + GetDefiniteName(object) + " up.")
          }
          object.parent = this
        }
      }
    </requestget>

    <requestdrop type="script">
      do (this, "checkagreement", QuickParams("command", "drop", "object", object))
      if (this.complies) {
        if (HasScript(object, "npc_drop")) {
          do (object, "npc_drop", QuickParams("npc", this))
        }
        else if ((HasBoolean(object, "npc_drop") and not GetBoolean(object, "npc_drop")) or (not HasAttribute(object, "npc_drop") and not GetBoolean(object, "drop"))) {
          msg ("'I can't drop that,' says " + GetDefiniteName(this) + ".")
        }
        else {
          msg ("'" + this.yesmsg + "' says " + CapFirst(GetDefiniteName(this)) + ", dropping " + GetDefiniteName(object) + ".")
          object.parent = this.parent
        }
      }
    </requestdrop>

    <requestgive type="script">
      do (this, "checkagreement", QuickParams("command", "give", "object", object))
      if (this.complies) {
        if (not DoesInherit(subject, "NpcType") and not subject = game.pov) {
          msg ("'Why would I give anything to " + GetDefiniteName(subject) + ",' says " + GetDefiniteName(this) + ".")
        }
        else {
          handled = false
          if (HasAttribute(this, "npc_give_script_list")) {
            if (DictionaryContains(this.npc_give_script_list, object.name)) {
              invoke (ScriptDictionaryItem(this.npc_give_script_list, object.name), QuickParams("subject", subject, "object", object))
              handled = true
            }
          }
          if (not handled) {
            if ((HasBoolean(object, "npc_drop") and not GetBoolean(object, "npc_drop")) or (not HasAttribute(object, "npc_drop") and not GetBoolean(object, "drop"))) {
              msg ("'I can't drop that,' says " + GetDefiniteName(this) + ".")
            }
            else {
              if (subject.gender = "you") {
                target = "you"
              }
              else {
                target = GetDefiniteName(subject)
              }
              msg ("'" + this.yesmsg + "' says " + CapFirst(GetDefiniteName(this)) + ", giving " + GetDefiniteName(object) + " to " + target + ".")
              object.parent = subject
            }
          }
        }
      }
    </requestgive>

    <requestgo type="script">
      do (this, "checkagreement", QuickParams("command", "go", "object", object))
      if (this.complies) {
        if (object.locked) {
          msg ("'It's locked,' says " + GetDefiniteName(this) + ".")
        }
        else {
          if (this.posture = null) {
            msg ("'" + this.yesmsg + "' says " + CapFirst(GetDefiniteName(this)) + ", heading " + object.alias + ".")
          }
          else if (this.posture_object = null) {
            msg ("'" + this.yesmsg + "' says " + GetDefiniteName(this) + ", standing up and going " + object.alias + ".")
          }
          else {
            msg ("'" + this.yesmsg + "' says " + GetDefiniteName(this) + ", getting off " + GetDefiniteName(this.posture_object) + ", and walking " + object.alias + "wards.")
          }
          this.posture_object = null
          this.posture = null
          this.listalias = this.alias
          this.parent = object.to
        }
      }
    </requestgo>

    <requestfollow type="script">
      do (this, "checkagreement", QuickParams("command", "follow"))
      if (this.complies) {
        if (this.following = game.pov) {
          msg ("'I am!' says " + GetDefiniteName(this) + ".")
        }
        else {
          if (this.posture = null) {
            msg ("'" + this.yesmsg + "' says " + GetDefiniteName(this) +", looking expectantly at you.")
          }
          else if (this.posture_object = null) {
            msg ("'" + this.yesmsg + "' says " + GetDefiniteName(this) + ", standing up, looking expectantly at you.")
          }
          else {
            msg ("'" + this.yesmsg + "' says " + GetDefiniteName(this) + ", getting off " + GetDefiniteName(this.posture_object) + ", looking expectantly at you.")
          }
          this.following = game.pov
          this.posture_object = null
          this.posture = null
          this.listalias = this.alias
          // Checks to see if "actions" has been set up (meaning at least on action has been added) to avoid errors.
          if (HasAttribute(this, "actions")) {
            while (ListCount (this.actions) > 0) {
              s = ListItem (this.actions, 0)
              list remove (this.actions, s)
              PrintIfDebug (this, "Deleted " + ToString(s))
            }
          }
        }
      }
    </requestfollow>

    <requestwait type="script">
      do (this, "checkagreement", QuickParams("command", "wait"))
      if (this.complies) {
        if (this.following = null) {
          msg ("'I am!' says " + GetDefiniteName(this) + ".")
        }
        else {
          msg ("'" + this.yesmsg + "' says " + GetDefiniteName(this) + ", tapping " + this.possessive + " foot.")
          this.following = game.pov
          this.posture_object = null
          this.posture = null
          this.listalias = this.alias
          // Checks to see if "actions" has been set up (meaning at least on action has been added) to avoid errors.
          if (HasAttribute(this, "actions")) {
            while (ListCount (this.actions) > 0) {
              s = ListItem (this.actions, 0)
              list remove (this.actions, s)
              PrintIfDebug (this, "Deleted " + ToString(s))
            }
          }
        }
      }
    </requestwait>

    <requeststandup type="script">
      do (this, "checkagreement", QuickParams("command", "standup"))
      if (this.complies) {
        if (this.posture = null) {
          msg ("'I am!' says " + GetDefiniteName(this) + ".")
        }
        else if (this.posture_object = null) {
          msg ("'" + this.yesmsg + "' says " + GetDefiniteName(this) + ", standing up.")
        }
        else {
          msg ("'" + this.yesmsg + "' says " + GetDefiniteName(this) + ", getting off " + GetDefiniteName(this.posture_object) + ".")
        }
        this.posture_object = null
        this.posture = null
        this.listalias = this.alias
      }
    </requeststandup>

    <requestposture type="script">
      do (this, "checkagreement", QuickParams("command", option, "object", object))
      if (this.complies) {


        if (object = null) {
          object = FindFurniture(option, this.parent)
        }
        if (this.posture = option and this.posture_object = object) {
          msg ("'I am!' says " + GetDefiniteName(this) + ".")
        }
        else if (not object = null) {
          if ((option = "sit" and object.cansiton = False) or (option = "stand" and object.canstandon = False) or (option = "recline" and object.canreclineon = False)) {
            msg (CapFirst(GetDefiniteName(this)) + " can't " + option + " on " + GetDefiniteName(object) + ".")
          }
          else {
            do (this, "doposture", QuickParams("posture", option, "object", object))
          }
        }
        else if (GetBoolean(game.pov.parent, "nositting")) {
          if (HasString(game.pov.parent, "nositmsg")) {
            msg(game.pov.parent.nosittingmsg)
          }
          else {
            msg(Replace(Template("PosturesNotAllowedHere"), "###", option))
          }
        }
        else {
          do (this, "doposture", QuickParams("posture", option, "object", null))
          this.listalias = this.alias
          // Checks to see if "actions" has been set up (meaning at least on action has been added) to avoid errors.
          if (HasAttribute(this, "actions")) {
            while (ListCount (this.actions) > 0) {
              s = ListItem (this.actions, 0)
              list remove (this.actions, s)
              PrintIfDebug (this, "Deleted " + ToString(s))
            }
          }
        }
      }
    </requestposture>
    
    <doposture type="script">
      // Does the posture, no checking
      s = "'" + this.yesmsg + "' says " + CapFirst(GetDefiniteName(this))
      
      if (not this.posture_object = object and not this.posture_object = null) {
        s = s + ", getting off " + GetDefiniteName(this.posture_object)
      }
      s = s + ". "
      if (not object = null) {
        do (this, posture + "onobj", QuickParams("object", object, "s", s))
      }
      else {
        do (this, posture + "onground", QuickParams("object", this.parent, "s", s))
      }

      this.posture = posture
      this.posture_object = object
      if (this.alias = null) this.alias = this.name
      if (not object = null) {
        this.listalias = this.alias + " (" + AddIng(posture) + " on " + ProcessText(GetDisplayName(object)) + ")"
      }
      else {
        this.listalias = this.alias + " (" + AddIng(posture) + ")"
      }
    </doposture>
    
    
    

    
    <!-- Postures -->
    
    <getoffobj type="script">
      msg (CapFirst(GetDisplayName(this)) + " " + Replace(GetString(this.posture_object, att), "###", GetDefiniteName(this.posture_object)))
    </getoffobj>

    
    <sitonobj type="script">
      msg (CapFirst(GetDefiniteName(this)) + " sits on " + GetDefiniteName(object) + ".")
    </sitonobj>
    
    <standonobj type="script">
      msg (CapFirst(GetDefiniteName(this)) + " stands on " + GetDefiniteName(object) + ".")
    </standonobj>
    
    <reclineonobj type="script">
      msg (CapFirst(GetDefiniteName(this)) + " lies down on " + GetDefiniteName(object) + ".")
    </reclineonobj>
    
    <sitonground type="script">
      if (not IsDefined("s")) s = ""
      if (HasString(object, "posture_surface")) {
        msg (s + CapFirst(this.gender)) + " sits on " + object.posture_surface + ".")
      }
      else {
        msg (s + CapFirst(this.gender) + " sits on the ground.")
      }
    </sitonground>
    
    <reclineonground type="script">
      if (not IsDefined("s")) s = ""
      if (HasString(object, "posture_surface")) {
        msg (s + CapFirst(this.gender) + " lies down on " + object.posture_surface + ".")
      }
      else {
        msg (s + CapFirst(this.gender) + " lies down on the ground.")
      }
    </reclineonground>
    
    <crouchonground type="script">
      if (not IsDefined("s")) s = ""
      if (HasString(object, "posture_surface")) {
        msg (s + CapFirst(this.gender) + " crouches down on " + object.posture_surface + ".")
      }
      else {
        msg (s + CapFirst(this.gender) + " crouches down on the ground.")
      }
    </crouchonground>
    
    <kneelonground type="script">
      if (not IsDefined("s")) s = ""
      if (HasString(object, "posture_surface")) {
        msg (s + CapFirst(this.gender) + " kneels down on " + object.posture_surface + ".")
      }
      else {
        msg (s + CapFirst(this.gender) + " kneels down on the ground.")
      }
    </kneelonground>
    
    <crawlonground type="script">
      if (not IsDefined("s")) s = ""
      if (HasString(object, "posture_surface")) {
        msg (s + CapFirst(this.gender) + " gets down on " + object.posture_surface + " on " + this.possessive + " hands and knees.")
      }
      else {
        msg (s + CapFirst(this.gender) + " gets down on ground on " + this.possessive + " hands and knees.")
      }
    </crawlonground>
    
  </type>  
  
  
  
  
  
  <type name="furniture_type">
    <canstandon type="boolean">false</canstandon>
    <stand type="script">
      if (this.canstandon) {
        Posture ("stand", this.standonmsg, this)
      }
      else {
        msg (Replace(this.nostandmsg, "###", GetDefiniteName(this)))
      }
    </stand>
    <standonmsg>[EditorNpcLibYouStepUpOnTo]</standonmsg>
    <standoffmsg>[EditorNpcLibYouStepOff]</standoffmsg>
    <nostandmsg>[EditorNpcLibYouCantStandOn]</nostandmsg>

    <cansiton type="boolean">true</cansiton>
    <sit type="script">
      if (this.cansiton) {
        Posture ("sit", this.sitonmsg, this)
      }
      else {
        msg (Replace(this.nositmsg, "###", GetDefiniteName(this)))
      }
    </sit>
    <sitonmsg>[EditorNpcLibYouSitOn]</sitonmsg>
    <sitoffmsg>[EditorNpcLibYouGetOffSit]</sitoffmsg>
    <nositmsg>[EditorNpcLibYouCantSitOn]</nositmsg>

    <canreclineon type="boolean">false</canreclineon>
    <recline type="script">
      if (this.canreclineon) {
        Posture ("recline", this.reclineonmsg, this)
      }
      else {
        msg (Replace(this.noreclinemsg, "###", GetDefiniteName(this)))
      }
    </recline>
    <reclineonmsg>[EditorNpcLibYouLieDownOn]</reclineonmsg>
    <reclineoffmsg>[EditorNpcLibYouGetOffLie]</reclineoffmsg>
    <noreclinemsg>[EditorNpcLibYouCantRecOn]</noreclinemsg>

    <displayverbs type="listextend">Stand on;Sit on;Lie on</displayverbs>
    <preferred_posture>sit</preferred_posture>
  </type>








  
  
  
  <type name="FemaleNpc">
    <inherit name="NpcType" />
    <inherit name="container_closed" />
    <inherit name="namedfemale" />
    <open type="boolean">false</open>
    <close type="boolean">false</close>
    <isopen type="boolean">false</isopen>
    <transparent />
    <listchildren />
    <listchildrenprefix>She is holding</listchildrenprefix>
    <contentsprefix>holding</contentsprefix>
    <blockingmessage>Not while she's got hold of it.</blockingmessage>
  </type>  

  
  <type name="MaleNpc">
    <inherit name="NpcType" />
    <inherit name="container_closed" />
    <inherit name="namedmale" />
    <open type="boolean">false</open>
    <close type="boolean">false</close>
    <isopen type="boolean">false</isopen>
    <transparent />
    <listchildren />
    <listchildrenprefix>He is holding</listchildrenprefix>
    <contentsprefix>holding</contentsprefix>
    <blockingmessage>Not while he's got hold of it.</blockingmessage>
  </type>  

  
  

  
  
  
  <type name="GroupType">
    <inherit name="NpcType" />
    <resetalias type="script"><![CDATA[
      l = GroupMembers(this)
      this.alias = FormatList (GroupMembers(this), ", ", " and ", "no one")
      if (ListCount(l) = 1) {
        npc = ObjectListItem(l, 0)
        this.gender = npc.gender
        this.article = npc.article
        this.possessive = npc.possessive
      }
      else {
        this.gender = "they"
        this.article = "them"
        this.possessive = "their"
      }
    ]]></resetalias>
    <_initialise_>
      do(this, "resetalias")
    </_initialise_>
    <visible type="boolean">false</visible>
  </type>
  
  <function name="NpcActionScript" parameters="Typ">
    goon = false
    foreach (o, AllObjects()) {
      if (Typ = "turn" and GetBoolean(o, "perturn")) {
        afterturn = GetInt(o, "afterturn")
        pastturn = GetInt(o, "pastturn")
        if (afterturn = pastturn) {
          o.pastturn = 1
          goon = true
        }
        else {
          IncreaseObjectCounter (o, "pastturn")
        }
      }
      if (Typ = "time" and GetBoolean(o, "pertime")) {
        aftertime = GetInt(o, "aftertime")
        pasttime = GetInt(o, "pasttime")
        if (aftertime = pasttime) {
          o.pasttime = 1
          goon = true
        }
        else {
          IncreaseObjectCounter (o, "pasttime")
        }
      }
      if (goon) {
        if (HasScript(o, "takeaturn")) {
          if (GetBoolean(o, "paused")) {
            o.paused = false
          }
          if (GetBoolean(o, "suspended")) {
            if (HasInt(o, "suspendedcount")) {
              o.suspendedcount = o.suspendedcount - 1
              if (o.suspendedcount = 0) {
                o.suspended = false
                if (HasScript(o, "resumeagenda")) {
                  do (o, "resumeagenda")
                }
                else {
                  do (o, "takeaturn")
                }
              }
            }
          }
          else {
            do (o, "takeaturn")
          }
        }
        JS.scrollToEnd ()
      }
    }
  </function>

  <turnscript name="NpcTurnScript">
    <enabled />
    <script>
      NpcActionScript ("turn")
    </script>
  </turnscript>

  <timer name="NpcTimerScript">
    <interval>1</interval>
    <enabled />
    <script>
      NpcActionScript ("time")
    </script>
  </timer>
  
  <!--
  Adds "ing" to a verb. Works for one syllable  words and words where the last syllable  is stressed.
  Otherwise, not so good...
  -->
  <function name="AddIng" parameters="s" type="string"><![CDATA[
    // if it ends "ie", make it y
    if (EndsWith(s, "ie")) {
      return (Mid(s, 1, LengthOf(s) - 2) + "ying")
    }
    
    // if it ends "e", drop the "e"
    if (EndsWith(s, "e")) {
      return (Mid(s, 1, LengthOf(s) - 1) + "ing")
    }

    // two vowels and then consonant, just add
    if (IsRegexMatch("[aeiou][aeiou][bcdfghjklmnpqrstvwxyz]$", s)) {
      return (s + "ing")
    }
    
    // one vowels and then consonant, double consonant (not w, x, y)
    if (IsRegexMatch("[aeiou][bcdfghjklmnpqrstvz]$", s)) {
      return (s + Mid(s, LengthOf(s), 1) + "ing")
    }
    
    return (s + "ing")
  ]]></function>
  

  
  
  
  
  <function name="PrintIfDebug" parameters="o, s"><![CDATA[
    if (GetBoolean(game, "npcdebug")) {
      msg ("{color:blue:{i:" + o.name + "} " + s + "}")
    }
  ]]></function>

  
  
  <function name="PrintIfHere" parameters="room, s">
    if (game.pov.parent = room) {
      msg (s)
      if (not GetObject("game_clock") = null) {
        game_clock.event = true
      }
    }
  </function>
  

  <!--
  Overrides function in ConvLib so NPCs get paused when the player talks to them.
  -->
  <function name="AfterTopicEvent">
    Pause (game.conversationalist)
  </function>
  
  
  
  <!--
  Gets a list of members of the given grpup
  -->
  <function name="GroupMembers" parameters="group" type="objectlist">
    return (FilterByAttribute(AllObjects(), "group", group))
  </function>


  
  <!--
  Gets a single member of a group (or the NPC if this is an NPC).
  Used for when we want one member of the group to open the door or whatever.
  -->
  <function name="Member" parameters="group" type="object">
    if (DoesInherit(group, "GroupType")) {
      return (PickOneObject(FilterByAttribute(AllObjects(), "group", group)))
    }
    else {
      return (group)
    }
  </function>

  <function name="NpcStopFollowing" parameters="npc">
    if(HasAttribute(npc, "actions")){
      if (ListCount(npc.actions) > 0){
        s = StringListItem(npc.actions, 0)
        if (StartsWith(s, "Follow:")) {
          list remove (npc.actions, s)
          PrintIfDebug (npc, "Stopped following")
        }
      }
    }
  </function>

  
  <!--
  Pauses the NPC or the group she belongs to for one turn.
  -->
  <function name="Pause" parameters="npc">
    if (HasAttribute(npc, "group")) {
      npc.group.paused = true
    }
    else {
      npc.paused = true
    }
  </function>

  <!--
  Suspends the NPC or the group she belongs to (indefinitely if count is zero, in count turns otherwise).
  -->
  <function name="SuspendAgenda" parameters="npc, count">
    if (HasAttribute(npc, "group")) {
      npc.group.suspended = true
      npc.group.suspendedcount = count
    }
    else {
      npc.suspended = true
      npc.suspendedcount = count
    }
  </function>
  
  <!--
  Resumes the NPC or the group she belongs to.
  -->
  <function name="ResumeAgenda" parameters="npc">
    if (HasAttribute(npc, "group")) {
      npc.group.suspended = false
    }
    else {
      npc.suspended = false
    }
  </function>
  
  <!--
  Heart of the NPC system; NPC will do one action.
  -->
  <function name="NpcAct" parameters="npc, s" type="boolean">
    ary = Split(s, ":")
    if (ListCount(ary) = 1) {
      PrintIfHere (npc.parent, s)
      f = true
    }
    else {
      objname = StringListItem(ary, 1)
      if (objname = "") {
        game.currentobj = null
      }
      else {
        game.currentobj = GetObject (objname)
        if (game.currentobj = null) {
          error ("Failed to find object in NpcAct: " + objname)
        }
      }
      game.currentnpc = npc
      f = Eval("Npc" + StringListItem(ary, 0) + "(game.currentnpc, game.currentobj)")
    }
    return (f)
  </function>

  
  <!--
  Can the NPC go that way?
  If there is no exit, then yes, the NPC can. It is up to the author to ensure
  that makes sense.
  If there is an exit, and it has a "npcallowedtouse" script this will be run,
  and this will return true if npc.allowedtoproceed gets set to true.
  If there is no such script, works as per player.
  -->
  <function name="NpcAllowedToMoveTo" parameters="npc, dest, comm" type="boolean">
    exitname = GetExitByLink (npc.parent, dest)
    if (exitname = null) {
      return (true)
    }

    exit = GetObject(exitname)
    if (HasScript(exit, "npcallowedtouse")) {
      npc.allowedtoproceed = false
      do (exit, "npcallowedtouse", QuickParams("npc", npc, "comm", comm))
      return (npc.allowedtoproceed)
    }

    return (exit.visible and not exit.locked)
  </function>

  <function name="NpcMove" parameters="npc, obj" type="boolean">
    if (not NpcAllowedToMoveTo(npc, obj, "Move")) {
      return (true)
    }
    
    oldroom = npc.parent
    npc.parent = obj
    if (DoesInherit(npc, "GroupType")) {
      foreach (o, GroupMembers(npc)) {
        o.parent = obj
      }
    }
    if (not oldroom = npc.parent) {
      // leaving
      if (oldroom = game.pov.parent) {
        exitname = GetExitByLink (oldroom, npc.parent)
        if (not exitname = null) {
          exit = GetObject(exitname)
          if (HasScript(exit, "npc_using")) {
            do (exit, "npc_using", QuickParams("npc", npc))
          }
          else {
            NpcLeaving (npc, exit)
          }
        }
      }
      // entering
      if (npc.parent = game.pov.parent) {
        exitname = GetExitByLink (npc.parent, oldroom)
        if (not exitname = null) {
          exit = GetObject(exitname)
          if (HasScript(exit, "npc_entering_by")) {
            do (exit, "npc_entering_by", d)
          }
          else {
            NpcEntering (npc, exit)
          }
        }
      }
    }
    return (true)
  </function>
  
  <!--
  Used by NpcMove to describe the NPC leaving the current room, giving the direction headed.
  -->
  <function name="NpcLeaving" parameters="npc, exit" type="boolean">
    msg(CapFirst(GetDisplayName(npc)) + " " + Conjugate(npc, "leave") + ", heading " + NiceDirection(exit, false) + ".")
  </function>
  
  <!--
  Used by NpcMove to describe the NPC leaving the current room, giving the direction headed.
  -->
  <function name="NpcEntering" parameters="npc, exit" type="boolean">
    msg(CapFirst(GetDisplayName(npc)) + " " + Conjugate(npc, "enter") + " from " + NiceDirection(exit, true) + ".")
  </function>
  
  <function name="NiceDirection" parameters="exit, addthe" type="string">
    switch (exit.alias) {
      case ("in") { s = "inside" }
      case ("out") { s = "outside" }
      case ("up") { s = "above" }
      case ("down") { s = "below" }
      default {
        if (addthe) {
          s = "the " + exit.alias
        }
        else {
          s = exit.alias
        }
      }
    }
    return (s)
  </function>
  
  <function name="NpcWait" parameters="npc, obj" type="boolean">
    if (obj = game.pov or HasScript(obj, "takeaturn")) {
      return (npc.parent = obj.parent)
    }
    else if (HasBoolean(obj, "locked")) {
      return (not obj.locked)
    }
    else {
      return (npc = obj.parent)
    }
  </function>

  <function name="NpcSearch" parameters="npc, obj" type="boolean">
    exit = PickOneUnlockedExit (npc.parent)
    oldroom = npc.parent
    NpcMove(npc, exit.to)
    return (obj.parent = npc.parent)
  </function>


  <function name="NpcGet" parameters="npc, obj" type="boolean">
    obj.parent = npc
    PrintIfHere (npc.parent, CapFirst(GetDisplayName(npc)) + " picks up the " + GetDisplayAlias(obj) + ".")
    return (true)
  </function>

  <function name="NpcDrop" parameters="npc, obj" type="boolean">
    obj.parent = npc.parent
    PrintIfHere (npc.parent, CapFirst(GetDisplayName(npc)) + " drops the " + GetDisplayAlias(obj) + ".")
    return (true)
  </function>

  <function name="NpcGive" parameters="npc, obj" type="boolean">
    obj.parent = game.pov
    PrintIfHere (npc.parent, CapFirst(GetDisplayName(Member(npc))) + " gives you the " + GetDisplayAlias(obj) + ".")
    return (true)
  </function>

  <function name="NpcLock" parameters="npc, obj" type="boolean">
    if (not obj.locked) {
      obj.locked = true
      PrintIfHere (npc.parent, CapFirst(GetDisplayName(Member(npc))) + " locks the " + GetDisplayAlias(obj) + ".")
    }
    return (true)
  </function>

  <function name="NpcUnlock" parameters="npc, obj" type="boolean">
    if (obj.locked) {
      obj.locked = false
      PrintIfHere (npc.parent, CapFirst(GetDisplayName(Member(npc))) + " unlocks the " + GetDisplayAlias(obj) + ".")
    }
    return (true)
  </function>

  <function name="NpcOpen" parameters="npc, obj" type="boolean">
    if (not obj.isopen) {
      obj.isopen = true
      PrintIfHere (npc.parent, CapFirst(GetDisplayName(Member(npc))) + " opens the " + GetDisplayAlias(obj) + ".")
    }
    return (true)
  </function>

  <function name="NpcClose" parameters="npc, obj" type="boolean">
    if (obj.isopen) {
      obj.isopen = false
      PrintIfHere (npc.parent, CapFirst(GetDisplayName(Member(npc))) + " closes the " + GetDisplayAlias(obj) + ".")
    }
    return (true)
  </function>

  <function name="NpcWear" parameters="npc, obj" type="boolean">
    if (not obj.worn) {
      obj.worn = true
      obj.parent = npc
      PrintIfHere (npc.parent, CapFirst(GetDisplayName(npc)) + " puts on the " + GetDisplayAlias(obj) + ".")
    }
    return (true)
  </function>

  <function name="NpcRemove" parameters="npc, obj" type="boolean">
    if (obj.worn) {
      obj.worn = false
      obj.parent = npc
      PrintIfHere (npc.parent, CapFirst(GetDisplayName(npc)) + " takes off the " + GetDisplayAlias(obj) + ".")
    }
    return (true)
  </function>

  <function name="NpcJoin" parameters="npc, obj" type="boolean">
    return (NpcInclude(obj, npc))
  </function>

  <function name="NpcPause" parameters="npc, obj" type="boolean">
    return (true)
  </function>

  <function name="NpcFollow" parameters="npc, obj" type="boolean">
    if (not npc.parent = obj.parent) {
      NpcGoTo(npc, obj.parent)
    }
    else if (HasAttribute(npc, "followidle")) {
      msg(PickOneString(npc.followidle))
    }
    return (false)
  </function>

  <function name="NpcGoToParent" parameters="npc, obj" type="boolean">
    return (NpcGoTo(npc, obj.parent))
  </function>

  <function name="GetRoute" parameters="npc, obj" type="objectlist">
    exitlist = NewObjectList()
    foreach (ex, AllExits()) {
      if (not GetBoolean(ex, "stopallnpcs") and not GetBoolean(ex, "stop" + npc.name) and not ex.locked and ex.visible) {
        list add (exitlist, ex)
      }
    }
    return (PathLib_GetPathExt(npc.parent, obj, exitlist, -1))
  </function>
  <function name="NpcGoTo" parameters="npc, obj" type="boolean">
    l = GetRoute(npc, obj)
    if (ListCount(l) = 0) {
      return (true)
    }
    exit = ObjectListItem(l, 0)
    NpcMove (npc, exit.to)
    return (ListCount(l) = 1)
  </function>

  <function name="NpcSit" parameters="npc, obj" type="boolean">
    npc.posture = "sit"
    npc.posture_object = obj
    PrintIfHere (npc.parent, CapFirst(GetDisplayName(npc)) + " sits on the " + GetDisplayAlias(obj) + ".")
    return (true)
  </function>

  <function name="NpcStand" parameters="npc, obj" type="boolean">
    if (DoesInherit(obj, "furniture_type")) {
      npc.posture = "stand"
      npc.posture_object = obj
      PrintIfHere (npc.parent, CapFirst(GetDisplayName(npc)) + " stands on the " + GetDisplayAlias(obj) + ".")
    }
    else {
      npc.posture = null
      npc.posture_object = null
      PrintIfHere (npc.parent, CapFirst(GetDisplayName(npc)) + " stands up.")
    }
    return (true)
  </function>

  <function name="NpcRecline" parameters="npc, obj" type="boolean">
    npc.posture = "recline"
    npc.posture_object = obj
    PrintIfHere (npc.parent, CapFirst(GetDisplayName(npc)) + " lies down on the " + GetDisplayAlias(obj) + ".")
    return (true)
  </function>

  <function name="NpcScript" parameters="npc, obj" type="boolean">
    npc.deletefromlist = true
    if (HasScript (npc, "npcscript")) {
      d = NewDictionary()
      dictionary add (d, "item", obj)
      do (npc, "npcscript", d)
    }
    return (npc.deletefromlist)
  </function>
  
  
  
  <!--
  These five are for groups only.
  -->
  <function name="NpcWaitFor" parameters="npc, obj" type="boolean">
    if (not DoesInherit(npc, "GroupType")) error (npc.name + " is not a group!")
    return (obj.group = npc)
  </function>

  <function name="NpcCount" parameters="npc, obj" type="boolean">
    if (not DoesInherit(npc, "GroupType")) error (npc.name + " is not a group!")
    return (ListCount(GroupMembers(npc)) = obj.count)
  </function>

  <function name="NpcInclude" parameters="npc, obj" type="boolean">
    if (not DoesInherit(npc, "GroupType")) error (npc.name + " is not a group!")
    obj.group = npc
    do(npc, "resetalias")
    npc.parent = obj.parent
    return (true)
  </function>

  <function name="NpcExclude" parameters="npc, obj" type="boolean">
    if (not DoesInherit(npc, "GroupType")) error (npc.name + " is not a group!")
    obj.group = null
    do(npc, "resetalias")
    return (true)
  </function>

  <function name="NpcDisband" parameters="npc, obj" type="boolean">
    if (not DoesInherit(npc, "GroupType")) error (npc.name + " is not a group!")
    foreach (member, GroupMembers(npc)) {
      member.group = null
    }
    do(npc, "resetalias")
    return (true)
  </function>
  
  
  
  


  <!--
  Path-finding.
  -->
  
  <!-- Find a path from start to end using a set of exits and maxlength passed. -->
  <function name="PathLib_GetPathExt" parameters="start, end, exits, maxlength" type="objectlist">
    <![CDATA[
    // From PathLib by Jay Nabonne
    //msg("GetPathExt from " + start + " to " + end)
    // It is more efficient to mark the rooms rather than track them in lists.
    if (not HasInt(game, "pathID")) {
      game.pathID = 0
    }
    // Bump the path ID for this path. This saves us from having to unmark all previously marked rooms.
    game.pathID = game.pathID + 1

    path = null
    current = NewList()
    entry = _PathLib_AddEntry(current, start)
    dictionary add(entry, "path", NewObjectList())
    length = 0
    iterations = 0
  	while (ListCount(current) <> 0 and path = null and (maxlength = -1 or length <= maxlength)) {
      iterations = iterations + 1
      //msg("iterations = " + iterations)
  		entry = current[0]
  		list remove(current, entry)
      room = entry["room"]
      //msg("room = " + room.name)
      room.pathlib_visited = game.pathID
      //msg("entry=" + entry)
      if (room = end) {
        path = entry["path"]
        //msg("path=" + path)
      } else {
        foreach (exit, exits) {
          toRoom = exit.to
          //msg("toRoom = " + toRoom)
          if (toRoom <> null) {
            if (exit.parent = room) {
              // This is a room to be investigated.
              if (GetInt(toRoom, "pathlib_current") <> game.pathID and GetInt(toRoom, "pathlib_visited") <> game.pathID) {
                // We have not touched this room yet. Add its exit to the list.
                newEntry = _PathLib_AddEntry(current, toRoom)
                // Assign to an object attribute to force a copy.
                game.PathLib_pathtemp = entry["path"]
                list add(game.PathLib_pathtemp, exit)
                dictionary add(newEntry, "path", game.PathLib_pathtemp)
                game.PathLib_pathtemp = null
                //msg("Added")
              }
            }
          }
        }
      }
      length = ListCount(entry["path"])
  	}
    //msg("iterations = " + iterations + ", path count = " + ListCount(path))
  	return (path)
    ]]>
  </function>

  <!-- Add a room entry to the list. -->
  <function name="_PathLib_AddEntry" parameters="list, room" type="dictionary">
    // From PathLib by Jay Nabonne
    <!-- msg ("Add entry: " + room.name + "(length:" + ListCount(list) + ")") -->
    entry = NewDictionary()
    dictionary add(entry, "room", room)
    list add(list, entry)
    room.pathlib_current = game.pathID
    return (entry)
  </function>
    
  <!-- Interface -->
    
  <!-- NPC compliance -->
  <tab>
    <parent>_ObjectEditor</parent>
    <caption>NPC</caption>
    <mustnotinherit>editor_room;editor_player</mustnotinherit>
    
    <control>
      <controltype>dropdowntypes</controltype>
      <caption>Type</caption>
      <types>[EditorNpcLibTypes]</types>
      <width>150</width>
    </control>
    
    <control>
      <controltype>textbox</controltype>
      <caption>[EditorNpcLibAgreementMessage]</caption>
      <attribute>yesmsg</attribute>
      <mustinherit>NpcType</mustinherit>
      <mustnotinherit>GroupType</mustnotinherit>
    </control>

    <control>
      <caption>[EditorNpcLibCheckAgreementScript]</caption>
      <controltype>script</controltype>
      <attribute>checkagreement</attribute>
      <mustinherit>NpcType</mustinherit>
      <mustnotinherit>GroupType</mustnotinherit>
    </control>
    
    <control>
      <controltype>label</controltype>
      <caption>[EditorNpcLibShouldSetCom]</caption>
      <mustinherit>NpcType</mustinherit>
      <mustnotinherit>GroupType</mustnotinherit>
    </control>    

    <control>
      <controltype>label</controltype>
      <caption>[EditorNpcLibShouldGiveARes]</caption>
      <mustinherit>NpcType</mustinherit>
      <mustnotinherit>GroupType</mustnotinherit>
    </control>    

    <control>
      <controltype>label</controltype>
      <caption>[EditorNpcLibCanUseCom]</caption>
      <mustinherit>NpcType</mustinherit>
      <mustnotinherit>GroupType</mustnotinherit>
    </control>    
    
    <control>
      <controltype>scriptdictionary</controltype>
      <caption>[EditorNpcLibScriptGivesObjAnoNpc]</caption>
      <attribute>npc_give_script_list</attribute>
      <keyprompt>[EditorNpcLibNameOfObjGiven]</keyprompt>
      <mustinherit>NpcType</mustinherit>
      <mustnotinherit>GroupType</mustnotinherit>
    </control>
    
    <control>
      <controltype>label</controltype>
      <caption>[EditorNpcLibCanUseSubAndObjLocVar]</caption>
      <mustinherit>NpcType</mustinherit>
      <mustnotinherit>GroupType</mustnotinherit>
    </control>    
    
    
  </tab>
  
  
  <!-- NPC actions -->
  <tab>
    <parent>_ObjectEditor</parent>
    <caption>[EditorNpcLibNpcActions]</caption>
    <mustinherit>NpcType</mustinherit>

    <control>
     <caption>[EditorNpcLibListOfActionsToPerform]</caption>
      <controltype>list</controltype>
      <attribute>actions</attribute>
      <width>200</width>
      <mustinherit>NpcType</mustinherit>
      <editprompt>[EditorNpcLibActionPrompt]</editprompt>
    </control>

    <control>
      <caption>[EditorNpcLibPerTurn]</caption>
      <controltype>checkbox</controltype>
      <attribute>perturn</attribute>
      <mustinherit>NpcType</mustinherit>
    </control>

    <control>
      <controltype>number</controltype>
      <caption>[EditorNpcLibAfterTurn]</caption>
      <attribute>afterturn</attribute>
      <onlydisplayif>this.perturn</onlydisplayif>
    </control>

    <control>
      <caption>[EditorNpcLibPerTime]</caption>
      <controltype>checkbox</controltype>
      <attribute>pertime</attribute>
      <mustinherit>NpcType</mustinherit>
    </control>  

    <control>
      <controltype>number</controltype>
      <caption>[EditorNpcLibAfterTime]</caption>
      <attribute>aftertime</attribute>
      <onlydisplayif>this.pertime</onlydisplayif>
    </control>

    <control>
      <controltype>title</controltype>
      <caption>[EditorNpcLibAvailableActions]</caption>
      <mustinherit>NpcType</mustinherit>
    </control>
      
    <control>
      <controltype>label</controltype>
      <caption>[EditorNpcLibMove]</caption>
      <mustinherit>NpcType</mustinherit>
    </control>
      
    <control>
      <controltype>label</controltype>
      <caption>[EditorNpcLibGoTo]</caption>
      <mustinherit>NpcType</mustinherit>
    </control>
      
    <control>
      <controltype>label</controltype>
      <caption>[EditorNpcLibGetDropGive]</caption>
      <mustinherit>NpcType</mustinherit>
    </control>
      
    <control>
      <controltype>label</controltype>
      <caption>[EditorNpcLibLockUnlockOpenCloseWearRemove]</caption>
      <mustinherit>NpcType</mustinherit>
    </control>
      
    <control>
      <controltype>label</controltype>
      <caption>[EditorNpcLibSitStandRecline]</caption>
      <mustinherit>NpcType</mustinherit>
    </control>
      
    <control>
      <controltype>label</controltype>
      <caption>[EditorNpcLibSearch]</caption>
      <mustinherit>NpcType</mustinherit>
    </control>

    <control>
      <controltype>label</controltype>
      <caption>[EditorNpcLibWait]</caption>
      <mustinherit>NpcType</mustinherit>
    </control>
      
    <control>
      <controltype>label</controltype>
      <caption>[EditorNpcLibPause]</caption>
      <mustinherit>NpcType</mustinherit>
    </control>
      
    <control>
      <controltype>label</controltype>
      <caption>[EditorNpcLibScript]</caption>
      <mustinherit>NpcType</mustinherit>
    </control>
      
    <control>
      <controltype>label</controltype>
      <caption>[EditorNpcLibOwnVerbs]</caption>
      <mustinherit>NpcType</mustinherit>
    </control>
      
    <control>
      <controltype>title</controltype>
      <caption>[EditorNpcLibTitleScript]</caption>
      <mustinherit>NpcType</mustinherit>
    </control>
      
    <control>
      <controltype>script</controltype>
      <caption>[EditorNpcLibRunWithNpcScript]</caption>
      <attribute>npcscript</attribute>
      <width>200</width>
      <mustinherit>NpcType</mustinherit>
    </control>
    
    <control>
      <controltype>label</controltype>
      <caption>[EditorNpcLibSetDelFromListToFalse]</caption>
      <mustinherit>NpcType</mustinherit>
    </control>
      
  </tab>
  

  <!-- Items for NPCs -->
  <tab>
    <parent>_ObjectEditor</parent>
    <caption>[EditorNpcLibItemsForNpcs]</caption>
    <mustnotinherit>editor_room; defaultplayer;NpcType</mustnotinherit>
    
    <control>
      <controltype>multi</controltype>
      <caption>[EditorNpcLibTakeNpc]</caption>
      <attribute>npc_take</attribute>
      <types>
        [EditorNpcLibTakeDropTypes]
      </types>
      <checkbox>[EditorNpcLibTakeNpcChk]</checkbox>
    </control>
    
    <control>
      <controltype>multi</controltype>
      <caption>[EditorNpcLibDropNpc]</caption>
      <attribute>npc_drop</attribute>
      <types>
        [EditorNpcLibTakeDropTypes]
      </types>
      <checkbox>[EditorNpcLibDropNpcChk]</checkbox>
    </control>
        
    
    <control>
      <controltype>dropdowntypes</controltype>
      <caption>Type</caption>
      <types>[EditorNpcLibFurnitureType]</types>
      <width>150</width>
    </control>
    
    <control>
      <controltype>title</controltype>
      <caption>[EditorNpcLibFurniture]</caption>
      <mustinherit>furniture_type</mustinherit>
    </control>

    <control>
      <controltype>dropdown</controltype>
      <caption>[EditorNpcLibPreferredPosture]</caption>
      <attribute>preferred_posture</attribute>
      <validvalues type="simplestringlist">sit;stand;recline</validvalues>
      <freetext/>
      <mustinherit>furniture_type</mustinherit>
    </control>  
    
    
    

    <control>
      <controltype>title</controltype>
      <caption>[EditorNpcLibStanding]</caption>
      <mustinherit>furniture_type</mustinherit>
    </control>
      
    <control>
      <caption>[EditorNpcLibCanStandOn]</caption>
      <controltype>checkbox</controltype>
      <attribute>canstandon</attribute>
      <width>200</width>
      <mustinherit>furniture_type</mustinherit>
    </control>

    <control>
      <controltype>textbox</controltype>
      <caption>[EditorNpcLibStandOnMsg]</caption>
      <attribute>standonmsg</attribute>
      <mustinherit>furniture_type</mustinherit>
      <onlydisplayif>this.canstandon</onlydisplayif>
    </control>

    <control>
      <controltype>textbox</controltype>
      <caption>[EditorNpcLibGetOffStandMsg]</caption>
      <attribute>standoffmsg</attribute>
      <mustinherit>furniture_type</mustinherit>
      <onlydisplayif>this.canstandon</onlydisplayif>
    </control>

    <control>
      <controltype>textbox</controltype>
      <caption>[EditorNpcLibNoStandingMsg]</caption>
      <attribute>nostandmsg</attribute>
      <mustinherit>furniture_type</mustinherit>
      <onlydisplayif>not this.canstandon</onlydisplayif>
    </control>

    
    
    
    <control>
      <controltype>title</controltype>
      <caption>[EditorNpcLibSitting]</caption>
      <mustinherit>furniture_type</mustinherit>
    </control>
      
    <control>
      <caption>[EditorNpcLibCanSitOn]</caption>
      <controltype>checkbox</controltype>
      <attribute>cansiton</attribute>
      <width>200</width>
      <mustinherit>furniture_type</mustinherit>
    </control>

    <control>
      <controltype>textbox</controltype>
      <caption>[EditorNpcLibSitOnMsg]</caption>
      <attribute>sitonmsg</attribute>
      <mustinherit>furniture_type</mustinherit>
      <onlydisplayif>this.cansiton</onlydisplayif>
    </control>

    <control>
      <controltype>textbox</controltype>
      <caption>[EditorNpcLibGetOffSitMsg]</caption>
      <attribute>sitoffmsg</attribute>
      <mustinherit>furniture_type</mustinherit>
      <onlydisplayif>this.cansiton</onlydisplayif>
    </control>

    <control>
      <controltype>textbox</controltype>
      <caption>[EditorNpcLibNoSittingMsg]</caption>
      <attribute>nositmsg</attribute>
      <mustinherit>furniture_type</mustinherit>
      <onlydisplayif>not this.cansiton</onlydisplayif>
    </control>

    
    
    




    <control>
      <controltype>title</controltype>
      <caption>[EditorNpcLibReclining]</caption>
      <mustinherit>furniture_type</mustinherit>
    </control>
      
    <control>
      <caption>[EditorNpcLibCanReclineOn]</caption>
      <controltype>checkbox</controltype>
      <attribute>canreclineon</attribute>
      <width>200</width>
      <mustinherit>furniture_type</mustinherit>
    </control>

    <control>
      <controltype>textbox</controltype>
      <caption>[EditorNpcLibReclineOnMsg]</caption>
      <attribute>reclineonmsg</attribute>
      <mustinherit>furniture_type</mustinherit>
      <onlydisplayif>this.canreclineon</onlydisplayif>
    </control>

    <control>
      <controltype>textbox</controltype>
      <caption>[EditorNpcLibGetOffRecMsg]</caption>
      <attribute>reclineoffmsg</attribute>
      <mustinherit>furniture_type</mustinherit>
      <onlydisplayif>this.canreclineon</onlydisplayif>
    </control>

    <control>
      <controltype>textbox</controltype>
      <caption>[EditorNpcLibNoRecliningMessage]</caption>
      <attribute>noreclinemsg</attribute>
      <mustinherit>furniture_type</mustinherit>
      <onlydisplayif>not this.canreclineon</onlydisplayif>
    </control>


    
    
    <control>
      <controltype>label</controltype>
      <caption>[EditorNpcLibNote]</caption>
      <mustinherit>furniture_type</mustinherit>
    </control>
  </tab>
    
    
  <!-- Rooms for NPCs -->
  <tab>
    <parent>_ObjectEditor</parent>
    <caption>[EditorNpcLibPostures]</caption>
    <mustnotinherit>editor_object; defaultplayer</mustnotinherit>
    
    <control>
      <controltype>checkbox</controltype>
      <attribute>nositting</attribute>
      <caption>[EditorNpcLibNoSittingChk]</caption>
    </control>

    <control>
      <controltype>textbox</controltype>
      <caption>[EditorNpcLibNoSittingMsg]</caption>
      <attribute>nositmsg</attribute>
      <onlydisplayif>GetBoolean(this, "nositting")</onlydisplayif>
    </control>

    <control>
      <controltype>textbox</controltype>
      <caption>[EditorNpcLibNoRecliningMessage]</caption>
      <attribute>noreclinemsg</attribute>
      <onlydisplayif>GetBoolean(this, "nositting")</onlydisplayif>
    </control>

    <control>
      <controltype>textbox</controltype>
      <caption>[EditorNpcLibSurfaceName]</caption>
      <attribute>posture_surface</attribute>
      <onlydisplayif>not GetBoolean(this, "nositting")</onlydisplayif>
    </control>
  </tab>

  
</library>
